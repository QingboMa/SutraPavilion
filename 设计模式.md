设计模式是软件开发中解决一类问题的通用方法。

使用设计模式能让你写出更优雅、可维护的代码，也正因如此，很多框架源码都用到了设计模式，你不学很难看懂。

#### 知识

- 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程
  - 单例模式
  - 工厂方法模式
  - 抽象工厂
  - 建造者模式
  - 原型模式
- 结构型模式：把类或对象结合在一起形成一个更大的结构
  - 适配器模式
  - 组合模式
  - 装饰器模式
  - 代理模式
  - 享元模式
  - 外观模式
  - 桥接模式
- 行为型模式：类和对象如何交互，及划分责任和算法
  - 迭代器模式
  - 模板方法模式
  - 策略模式
  - 命令模式
  - 状态模式
  - 责任链模式
  - 备忘录模式
  - 观察者模式
  - 访问者模式
  - 中介者模式
  - 解释器模式

#### 学习建议

先理解概念，了解每个设计模式的特点和应用场景，再多加练习，运用到实际项目。

#### 经典面试题

1. 单例模式有哪些实现方式？有哪些优缺点？请手写其中一种
2. 你用过哪些设计模式，为什么用它？

#### 资源

- 书籍
  - ⭐《图解设计模式》（强烈推荐这本书，正是用 Java 语言实现，图多、有示例代码、有习题和答案，很不错）
  - 《Head First 设计模式》
  - 《大话设计模式》
  - 《设计模式：可复用面向对象软件的基础》（大黑书，有能力的话也可以去读）
- 视频
  - 尚硅谷图解 Java 设计模式：[https://www.bilibili.com/video/BV1G4411c7N4](https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1G4411c7N4)
- 文档
  - 菜鸟教程：[https://www.runoob.com/design-pattern/design-pattern-tutorial.html](https://gitee.com/link?target=https%3A%2F%2Fwww.runoob.com%2Fdesign-pattern%2Fdesign-pattern-tutorial.html)
  - 图说设计模式：[https://design-patterns.readthedocs.io/zh_CN/latest/](https://gitee.com/link?target=https%3A%2F%2Fdesign-patterns.readthedocs.io%2Fzh_CN%2Flatest%2F)

# 创建型模式

**创建型模式（Creational Pattern）：**对类的实例化过程进行了抽象，能够将软件模块中**对象的创建**和对象的使用分离。

（5种）单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式

## 单例模式

### 懒汉式

```java
package com.mqb.design.signton.lazy;

/**
 * @author maqingbo
 * @date 2023/2/20 19:51
 * @email qingbo.my@gmail.com
 */
public class LazySigntonTest {

    public static void main(String[] args) {
        //单线程
       LazySignton instance = LazySignton.getInstance();
       LazySignton instance1 = LazySignton.getInstance();
       System.out.println(instance1==instance);
    }
}

class LazySignton {
    private static LazySignton lazySignton;

    private LazySignton() {

    }

    public  static LazySignton getInstance() {

        if (lazySignton == null) {
            lazySignton = new LazySignton();
        }
        return lazySignton;
    }

}

```

上面这种方法在多线程的情况下会出现多个实例，解决方法是在`getInstance`方法上添加`synchronized`

```java
  public synchronized static LazySignton getInstance() {

        if (lazySignton == null) {
            lazySignton = new LazySignton();
        }
        return lazySignton;
    }
```

但是加锁会造成性能问题,优化点，当lazySignton为空的时候加锁，不为空的时候直接取用

```java
   public  static LazySignton getInstance() {

        if (lazySignton == null) {
            //防止多线程同时对该类加锁
            synchronized(LazySignton.class){
                //双重检查
                if (lazySignton == null){
                lazySignton = new LazySignton();
                }
            }
        }
        return lazySignton;
    }
```

在字节码成面看，上面的方法同样会有问题，可能会出现一个空指针的问题

当t1线程进行 分配空间->引用复制但是还没有进行初始化的时候，

t2线程发现instance有值了，直接返回instance，这时候再去调用就可能会出现NPE的问题

解决方法（使用volatile，`防止指令重排`(在字节码成面，就会按照：分配空间->初始化->引用赋值的顺序执行)，volatile的另外两点：保证多线程间的可见性。不保证原子性）

```java

class LazySignton {
    private volatile static LazySignton lazySignton;

    private LazySignton() {
    }
    public  static LazySignton getInstance() {

        if (lazySignton == null) {
            synchronized(LazySignton.class){
                if (lazySignton == null){
                lazySignton = new LazySignton();
                }
            }
        }
        return lazySignton;
    }
}
```

### 饿汉式

```java

class HungrySignton {
    private static HungrySignton instance = new HungrySignton();

    private HungrySignton() {
    }

    public static HungrySignton getInstance() {
        return instance;
    }
}

```

基于JVM的类加载机制保证线程的安全

类加载(真正时候这个类的时候触发)的步骤，

1. 将二进制文件加载内存并生成class数据结构
2. 连接： 验证、准备(给类的静态成员变量赋默认值，0,null...)、解析
3. 初始化：给类的静态变量赋值

### 静态内部类

```java
class StaticInnerClassSign {
    private static class StaticInner {
        private static StaticInnerClassSign instance = new StaticInnerClassSign();
    }
    private StaticInnerClassSign(){}
    
    public StaticInnerClassSign getInstance(){
        return StaticInner.instance;
    }
}
```

也是基于JVM的类加载机制实现

注意：通过反射可以获取多个实例，可以在静态内部类处理

修改静态内部类

```java
class StaticInnerClassSign {
    private static class StaticInner {
        private static StaticInnerClassSign instance = new StaticInnerClassSign();
    }
    private StaticInnerClassSign(){
        if (StaticInner.instance!=null){
            throw new RuntimeException("单例模式实例化失败，存在多个实例");
        }
    }
    public StaticInnerClassSign getInstance(){
        return StaticInner.instance;
    }
}
```

利用反射获取实例

```java
   @SneakyThrows
    public static void main(String[] args) {
        Class<StaticInnerClassSign> staticInnerClassSignClass = StaticInnerClassSign.class;
        Constructor<StaticInnerClassSign> declaredConstructor = staticInnerClassSignClass.getDeclaredConstructor();
        declaredConstructor.setAccessible(true);
        StaticInnerClassSign staticInnerClassSign = declaredConstructor.newInstance();
        StaticInnerClassSign instance = StaticInnerClassSign.getInstance();
        System.out.println(staticInnerClassSign==instance);

    }
```

![image-20230220211955227](asset/设计模式/pic/image-20230220211955227.png)



## 工厂模式

### 简单工厂模式

```java
/**
 * 水果的接口
 */
public interface IFruit {
    /**
     * 吃水果的方式
     */
    void eat();
}
```

两个实现类

```java
public class Apple implements IFruit{
    @Override
    public void eat() {
        System.out.println("苹果需要削皮");
    }
}
public class Orange implements IFruit{
    @Override
    public void eat() {
        System.out.println("橘子需要剥皮");
    }
}
```

使用

```java
public class SimpleFactory {
    public static void main(String[] args) {
        IFruit fruit = new Apple();
        fruit.eat();
    }
}
```

## 抽象工厂模式









# 结构性模式

**结构型模式（Structural Pattern）**：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像**搭积木**，可以通过简单积木的组合形成复杂的、功能更为强大的结构。

（7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式



# 行为型模式

**行为型模式（Behavioral Pattern）**：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的**相互作用**。

（11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式